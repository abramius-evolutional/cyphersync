API


@auth

    /auth/registration (POST)
        @input
            email - валидная почта пользвоателя
            password - шифрованный пароль пользователя
            secret - шифр md5(email + secret_phrase + password). На время разработки secret_phrase='fuck you'
            name - имя пользователя (50 символов)
            (optional) details - json строка дополнительных данных о пользователе, полная свобода использования
            (optional) avatar - изображение аккаунта. (на бэке не проверяется объем, давайте на клиенте
                будем уменьшать до 1 метра)
        @output
            200 - если все гуд и пользователь создан, кроме статуса ничего не возвращается
            404 - если email уже занят
            400, 401, 405
        @info
            Вновь созданому пользователю будет отправлено письмо на почту со ссылкой для подтверждения аккаунта


    /auth/details (GET)
        @input
            email
            password
            secret
        @output
            {
                "details": <details, указанная при регистрации пользователя>
            }

    /auth/login (GET)
        @input
            email
            password
            secret
            device_id - айдишник девайса 
            pub_key - публичный ключ для данного device_id (приватный ключ должен храниться на устройстве device_id)
            device_name - имя девайса (лучше запросить его у пользователя, так как для подтверждения нового устройства
                члена группы другим члетам придется сказать - мол такой то пользователь добавил device_name устройство
                и просит для него разрешение. Кто то должен будет подтвердить это - то есть дать ему ключ к файлам).
        @output
            200 - {
                'accessToken': <accessToken>
            }
            404 - если пользователь с такой почтой или паролем не найден
            400, 401, 405

    /auth/setpushidentifier/ (POST)
        @input
            access_token
            vendor - (ios/android)
            push_identifier - id который нужен для отправки push сообщения
        @output
            {
                'status': 'saved'
            }

    /auth/logout (GET)
        @use_case1
            @input
                accessToken - авторизационный токен
            @output
                200 - логаут производится для данного пользователя для того устройства, с которого он логинился
                    и получил этот токен
                404 - если токен не найден
                405
            @info
                Этот путь нужно использовать если человек хочет разлогиниться с одного устройства и не вызывать
                необходимость повторной авторизации на других устройствах
        @use_case2
            @input
                email
                password
                secret
                (optional) device_id
            @output
                200 - логаут пользователя для устройства device_id если он передан
                200 - логаут пользователя для всех устройств пользователя если device_id не указан
                401, 404, 405
            @info
                Этот путь стоит использовать если либо нет авторизационного токена, либо нужно разлогиниться
                со всех устройств


    /auth/confirm_email (GET)
        @info
            Ручка, по которой переходит пользователь подтверждая свою почту (ссылка из письма)


    /auth/change_password_request (GET)
        @input
            email
        @output
            200 - все нормально, отправлено письмо пользователю на почту со ссылкой для изменения пароля
            401, 404, 405
        @info


    /auth/change_password (GET)
        @info
            Ручка, по которой переходит пользователь пытаясь изменить пароль (ссылка из письма)

    /auth/change (POST)
        @input
            accessToken - выданный при логине
            (optional) name
            (optional) avatar
            (optional) details
        @output
            200 - { "status": "updated" }

!   @person
    
    /person/person_about (GET)
        @input
            accessToken - авторизационный токен
        @output
            Информация о пользователе

    /person/device_about (GET)
        @input
            accessToken - авторизационный токен
        @output
            Информация о девайсе

    /person/person_devices (GET)
        @input
            accessToken - авторизационный токен
        @output
            Список девайсов пользователя

@content
    
    /content/roles (GET)
        @input
            accessToken - авторизационный токен
        @output
            Возвращается список ролей пользователя в группах. (По сути это список групп)
            Идет пометка о типе роли, так же информация о группе, ее имя, приватная ли группа
            Так же по группе возвращается список пользователей которые роли в этой группе.
            если поле expiration_datetime имеет значение, значит роль подлежит удалению в указанный
            момент времени. Это возникает, когда role_type имеет значение "predeleted"
            Данная роль дает право на чтение файлов но не на добавление и тп.
            {
                "roles": [
                    {
                        "id": 450,
                        "role_type": "administrator",
                        "is_confirmed": false,
                        "expiration_datetime": null,
                        "group": {
                            "id": 1, 
                            "creator": {
                                "id": 195, 
                                "email": "iphoneAupload@xxx.com", 
                                "role_type": null
                            },
                            "name": "Private group", 
                            "is_private": true, 
                            "users": [
                                {
                                    "id": 1, 
                                    "email": "userA@xxx.com", 
                                    "details": "{}", 
                                    "role_type": "administrator"
                                }
                            ]
                        }
                    },
                    ...
                ]
            }

    /content/add_file (GET)
        @input
            accessToken
            group_ids (например [8,9]) - id тех групп, пользователям которых нужно дать доступ к этому файлу
            size_bytes - число байтов в файле
        @output
            возвращается список публичников пользователей, которыми нужно зашифровать секретный ключ файла
            и отправить этот список вместе с файлом в запросе для обеспечения доступа пользователей этих групп к файлу
            {
                "keys": [
                    {
                        "pub_key": "304802 ... 3010001", 
                        "email": "userA@xxx.com", 
                        "device_name": "iphoneA",
                        "device_id": id устройства
                    },
                    ...
                ]
            }
            Если место закончилось - возвращается ошибка 403
            {
                'status': 'memory error'
            }

    /content/add_file/ (POST)
        @input
            accessToken
            size_bytes - размер файла в байтах
            group_ids - тот же набор групп что и в запросе на добавление файла
            item_id (optional) - указывается, в случае, если файл уже залит и нужно его добавить в другую групппу
            metadata - произвольная json строка - на сервере не парсится
            cyphers - список, зашифрованных публичными ключами устройств, ключей
                к добавляемому файлу. Это словарь, ключами которого являются id устройств
                а значениями - шифры ключа файла публичниками данного устройства.
                {
                    32: '6dd1fd ... 7d53cff',
                    ...
                }
            aws_data (указывается если не указан item_id) - данные о залитом файле на AWS S3
                {
                    "url": <публичная ссылка на файл>,
                    "bucket": <bucket в который был залит файл>,
                    "key": <имя залитого файла (включая путь)>,
                    "hash_data": <хеш залитых данных. Для хеша используется SHA256>,
                    "size_bytes": <размер файла в байтах>
                }
        @info
            Нужно обязательно указать либо item_id либо aws_data
        @output
            {
                "status": "saved",
                "item": {
                    "id": 205, 
                    "data": {
                        "id": 77, 
                        "url": "media/data/92/97/9297ab3fbd56b42f6566284119238125", 
                        "version": 1, 
                        "hash_sum": "9297ab3fbd56b42f6566284119238125", 
                        "dt_initialization": "26-09-15 13:01"
                    }, 
                    "meta": {
                        "details": "{\"type\": \"video\"}", 
                        "version": 1, 
                        "hash_sum": "a9b6fcae4c07732d043f72166c2eb362", 
                        "dt_initialization": "26-09-15 15:02", 
                        "dt_modification": "26-09-15 15:02"
                    }, 
                    "cypher_key": "", 
                    "details": ""
                }
            }
            ошибки или 200

    /content/files/ (GET)
        @input
            accessToken
        @output
            возвращается список файлов, к которым пользователь имеет доступ с правом на чтение. (позже добавлю детали прав к файлам.)
            url - ссылка для скачивания данных
            version - версия файла
            cypher_key - секретный ключ к файлу, зашифрованный публичным ключом устройства, с которого
                происходит запрос
            {
                "items": [
                    {
                        "id": 10, 
                        "data": {
                            "id": 1, 
                            "url": "media/data/3c/3c1c0e9df4d4532e86054dcf9b87c8a1", 
                            "version": 1, 
                            "hash_sum": "3c1c0e9df4d4532e86054dcf9b87c8a1",
                            "dt_initialization": "18-08-15 09:56"
                        }, 
                        "meta": {
                            "details": "{meta 1}", 
                            "version": 1, 
                            "hash_sum": "000",
                            "dt_initialization": "18-08-15 09:58", 
                            "dt_modification": "18-08-15 09:58"
                        }, 
                        "cypher_key": "325faf8cbc48c3bf9cb1c35cc0a41d395d81a1c82d6bacac9183d4c63618d02df5d0cdef5aae776fa11c12c2cf02bcddc0f2dfc6ee2db95494a3382346a6ad3f"
                        "details": {
                            "groups": [
                                {
                                    "is_private": false, 
                                    "id": 146, 
                                    "role_type": "administrator", 
                                    "name": "creating group!!!!!"
                                }
                            ]
                        }
                    },
                    ...
                ]
            }

    /content/add_role/ (GET)
        @input
            accessToken
            target_email - пользователь, которому нужно дать доступ к файлом группы
            group_id - id группы
        @output
            {
                "file_keys": [
                    {
                        "data_item_id": 217, 
                        "cypher_key": "75744ea ... 2972b"
                    },
                    ...
                ],
                "target_devices": [
                    {
                        "pub_key": "304802 ... 10001", 
                        "device_id": 198
                    },
                    ...
                ],
                "my_pub_key": "3048024 ... 70001"
                }
            }

            file_keys - список ключей файлов, доступных в этой группе. А так же секретные ключи к этим файлам,
                зашифрованные публичником девайса, с которого делается данный запрос.
            target_devices - список девайсов добавляемого пользователя. Там же их публичники.
            my_pub_key - публичник пользователя, который выполняет запрос.
            На клиенте нужно расшифровать cypher_key каждого файла и зашифровать его всеми публичниками девайсов
            целевого пользователя.

    /content/add_role/ (POST)
        @input
            accessToken
            group_id - id той же группы, что и в get запросе
            target_email - email добавляемого пользователя
            role_type - типо роли ("administrator", "visitor")
            cyphers - список зашифрованных ключей к файлу разными публичниками. Выглядит так:
                [
                    {
                        "device_id": 209,
                        "data_item_id": 225,
                        "secret_key": "9499c ... 80520"
                    },
                    ...
                ]
        @output
            ответ в случае успеха
            {
                "status": "added 10 accesses"
            }

    /content/confirm_role/ (GET)
        @input
            accessToken
            role_id - id роли, которую пользователь подтверждает
        @output
            {
                'status': 'confirmed'
            }

    /content/delete_role/ (GET)
        @input
            accessToken
            role_id - id роли, которую нужно удалить
        @output
            {
                'status': 'role has been deleted'
            }
        @info
            Роль может быть удалена только тем, кто ее создавал, либо тем, для кого она создана
            то есть чья роль. 

    /content/create_group/ (POST)
        @input
            accessToken
            name - имя новой группы
            group_type - (optional) тип группы. опциональное поле с произвольным текстовым значением (200 сим. макс.)
        @output
            Создает новую группа и роль для пользователя который ее создает типа administrator
            Возвращает информацию о вновь созданной роли
            Информация о роли в таком же виде как и в запросе (/content/roles (GET))

    /content/delete_group/ (POST)
        @input
            accessToken
            group_id - id удаляемой группы
        @output
            {
                'status': 'group has been deleted'
            }

    /content/change_file/ (POST)
        @input
            accessToken
            item_id - id изменяемого файла
            metadata - новые метаданные файла
            prev_hash_meta - хэш-сумма метаданных, которая была получена в момент скачивания файла
            prev_hash_data (optional) - хэш-сумма данных, которая была получена в момент скачивания файла
            aws_data (указывается если не происходило изменение данных) - данные о залитом файле на AWS S3
                {
                    "url": <публичная ссылка на файл>,
                    "bucket": <bucket в который был залит файл>,
                    "key": <имя залитого файла (включая путь)>,
                    "hash_data": <хеш залитых данных. Для хеша используется SHA256> 
                }
        @output
            {
                "status": "...",
                "item": < информация о измененном файле, аналогична описанию файлов в /content/files/ (GET) >
            }
        @info
            hash-суммы необходимы для валидации состояния файла. Если на момент попытки изменения hash-сумма на сервере совпадает
            с той, которая была на момент скачивания данным пользователем файла - значит файл пока никто не менял
            и пользователь может его изменить (метаданные или данные) без потери информации. тогда меняется файл item_id и 
            возвращается в результате обновленная информация о нем. Если же hash не совпадает, то значит кто-то уже 
            успел изменить данный файл. Тогда произойдет создание еще одного файла с версией изменения данного пользователя 
            и для него скопируются все права доступа что соответствовали исходному файлу. Если нужно изменить только метаданные -
            не нужно грузить сами данные файла, только metadata и prev_hash_meta. Если же нужно изменить и/или данные, то нужно
            передать так же data, prev_hash_data.

    /content/delete_file/ (GET)
        @input
            accessToken
            group_id - id группы, из которой нужно удалить файл
            item_id - id удаляемого файла
        @output
            {
                'status': 'item has been deleted from group'
            }
        @info
            Если файл находится в нескольких группах, то он удалится только из той, которая указана.
            Полное удаление данных происходит когда файл больше не содержится не в одной группе.

    /content/check_accesses/ (GET)
        @input
            accessToken
        @output
            {
                "missing_cypher_accesses": [
                    {
                        "cypher_key": "7b52e23f549cedff8d8752c0e21023fedb2ac6ceea5ef66059353d6a11d8ddfa74435651814a98c981cf5f4f5acac5c7516d21c95bc464ac6d1d8f765d76850e", 
                        "group_id": 1048, 
                        "user_id": 804, 
                        "user": "userB@xxx.com", 
                        "device": "androidB", 
                        "pub_key": "30480241008f42abebf1a8f50af99ae4084e4238db7be2f928972b8428aedd8b73ea0151478e62b6c812642ab495e74fafed8e67b653f9d0bd74bab356cec75edd27fc4ce90203010001", 
                        "group_name": "A and C", 
                        "data_item_id": 183, 
                        "device_id": 784
                    },
                    ...
            }
        @info
            Ручка запрашивает все группы в которых обращающийся пользвоатель является админом.
            Для каждой такой группы выбираются пользователи и файлы. Проверяется имеют ли все
            пользователи шифровальный доступ к файлам согласно своим ролям. Если находится ситуация
            при которой пользователь имеет роль на чтение или запись файла, однако шифровального доступа 
            к данным не находится, то он добавляется в возвращаемый список ошибок шифровального доступа. 
            Список таких ошибок возвращается. Тот кто дергает ручку должен (если он хочет подтвердить 
            доступ для этих пользователей) для каждого элемента списка взять 
            cypher_key, расшифровать его своим приватным ключом и результат зашифровать pub_key.
            Таким образом он подготовит доступ для пользвоателя к нужному файлу. Для каждого элемента нужно
            дернуть ручку add_cypher_access с этими параметрами.

    /content/add_cypher_access/ (POST)
        @input
            accessToken
            cypher_key - секретный ключ к файлу зашифрованный публичным ключом девайса device_id
            device_id - id девайса для которого предоставляется доступ
            data_item_id - id данных, доступ к которым предоставляется
        @output
            {
                'status': 'saved'
            }

    /content/actual_aws_info/ (GET)
        @input
            accessToken
            hash_data - хеш данных, которые предполагается заливать.
        @output
            {
                "aws_bucket": "actual bucket name",
                "aws_dir": "current subdir"
            }

